#Requires -Modules @{ ModuleName = 'Pester'; ModuleVersion = '5.0.0' }

<#
.SYNOPSIS
    Unit tests for Test-ReconstructedRar function.

.DESCRIPTION
    Tests RAR file validation against SFV CRCs.
    Uses mocking to isolate from file system dependencies.
#>

BeforeAll {
    Import-Module "$PSScriptRoot/../TestHelpers.psm1" -Force
    Initialize-TestEnvironment

    $script:tempDir = New-TestTempDirectory -Prefix 'TestRarTest'
}

AfterAll {
    Remove-TestTempDirectory -Path $script:tempDir
}

Describe 'Test-ReconstructedRar' {

    Context 'SFV file parsing' {

        It 'Parses SFV format correctly via ConvertFrom-SfvFile' {
            InModuleScope 'ReScenePS' -Parameters @{ dir = $script:tempDir } {
                # Create a test SFV file
                $sfvPath = Join-Path $dir 'test.sfv'
                $sfvContent = @"
; Generated by TestSFV
file1.rar DEADBEEF
file2.rar 12345678
file3.r00 ABCD1234
"@
                Set-Content -Path $sfvPath -Value $sfvContent

                $result = ConvertFrom-SfvFile -FilePath $sfvPath

                $result.Count | Should -Be 3
                $result['file1.rar'] | Should -Be 3735928559  # 0xDEADBEEF
                $result['file2.rar'] | Should -Be 305419896   # 0x12345678
                $result['file3.r00'] | Should -Be 2882343476  # 0xABCD1234
            }
        }

        It 'Handles SFV with comments' {
            InModuleScope 'ReScenePS' -Parameters @{ dir = $script:tempDir } {
                $sfvPath = Join-Path $dir 'comments.sfv'
                $sfvContent = @"
; This is a comment
; Another comment
release.rar AABBCCDD
"@
                Set-Content -Path $sfvPath -Value $sfvContent

                $result = ConvertFrom-SfvFile -FilePath $sfvPath

                $result.Count | Should -Be 1
                $result['release.rar'] | Should -Be 2864434397  # 0xAABBCCDD
            }
        }
    }

    Context 'CRC comparison logic' {

        It 'Compares CRC32 values correctly' {
            InModuleScope 'ReScenePS' {
                # Test CRC comparison logic
                $expectedCrc = [uint32]3735928559  # 0xDEADBEEF
                $actualCrc = [uint32]3735928559

                $actualCrc -eq $expectedCrc | Should -BeTrue
            }
        }

        It 'Detects CRC mismatch' {
            InModuleScope 'ReScenePS' {
                $expectedCrc = [uint32]3735928559  # 0xDEADBEEF
                $actualCrc = [uint32]305419896     # 0x12345678

                $actualCrc -eq $expectedCrc | Should -BeFalse
            }
        }
    }

    Context 'File existence checks' {

        BeforeAll {
            $script:testOutputPath = Join-Path $script:tempDir 'rar-output'
            New-Item -Path $script:testOutputPath -ItemType Directory -Force | Out-Null

            # Create test RAR file
            $script:testRar = Join-Path $script:testOutputPath 'file1.rar'
            [System.IO.File]::WriteAllBytes($script:testRar, [byte[]]@(0x52, 0x61, 0x72, 0x21))
        }

        It 'Detects existing RAR files' {
            Test-Path $script:testRar | Should -BeTrue
        }

        It 'Handles missing RAR files' {
            $missingRar = Join-Path $script:testOutputPath 'missing.rar'
            Test-Path $missingRar | Should -BeFalse
        }
    }

    Context 'Get-Crc32 integration' {

        BeforeAll {
            $script:crcTestFile = Join-Path $script:tempDir 'crc-test.bin'
            # "test" has CRC32 of 0xD87F7E0C = 3632233996
            [System.IO.File]::WriteAllBytes($script:crcTestFile, [System.Text.Encoding]::ASCII.GetBytes('test'))
        }

        It 'Calculates CRC32 for RAR files' {
            InModuleScope 'ReScenePS' -Parameters @{ file = $script:crcTestFile } {
                $result = Get-Crc32 -FilePath $file

                $result | Should -Be 3632233996  # Known CRC32 of "test"
            }
        }
    }

    Context 'Temp file cleanup' {

        It 'Uses temp file for extracted SFV' {
            InModuleScope 'ReScenePS' {
                # The function creates a temp file with pattern:
                # $tempSfv = [System.IO.Path]::GetTempFileName() + ".sfv"
                $tempPath = [System.IO.Path]::GetTempFileName() + ".sfv"

                $tempPath | Should -Match '\.sfv$'
                $expectedTempDir = [regex]::Escape([System.IO.Path]::GetTempPath().TrimEnd('\', '/'))
                $tempPath | Should -Match $expectedTempDir

                # Clean up
                if (Test-Path $tempPath) { Remove-Item $tempPath }
            }
        }
    }

    Context 'Parameter validation' {

        It 'Requires SrrFile parameter' {
            InModuleScope 'ReScenePS' -Parameters @{ dir = $script:tempDir } {
                { Test-ReconstructedRar -OutputPath $dir } | Should -Throw "*SrrFile*"
            }
        }

        It 'Requires OutputPath parameter' {
            InModuleScope 'ReScenePS' -Parameters @{ dir = $script:tempDir } {
                { Test-ReconstructedRar -SrrFile "$dir\test.srr" } | Should -Throw "*OutputPath*"
            }
        }
    }

    Context 'Export-StoredFile dependency' {

        It 'Calls Export-StoredFile with SFV pattern' {
            InModuleScope 'ReScenePS' -Parameters @{ dir = $script:tempDir } {
                # Create minimal SRR that will fail on Export-StoredFile
                $srrFile = Join-Path $dir 'dep-test.srr'
                [System.IO.File]::WriteAllBytes($srrFile, [byte[]]::new(10))

                # Should attempt to export SFV and fail
                { Test-ReconstructedRar -SrrFile $srrFile -OutputPath $dir } |
                    Should -Throw
            }
        }
    }

    Context 'Validation results' {

        It 'Tracks valid and failed counts' {
            InModuleScope 'ReScenePS' {
                # Test the counting logic used in the function
                $validCount = 0
                $failCount = 0

                # Simulate successful validation
                $validCount++
                $validCount | Should -Be 1

                # Simulate failed validation
                $failCount++
                $failCount | Should -Be 1

                # All valid check
                $allValid = ($failCount -eq 0)
                $allValid | Should -BeFalse
            }
        }
    }
}
